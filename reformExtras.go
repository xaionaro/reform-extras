package reformExtras

import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	_ "github.com/mattn/go-sqlite3"
	"github.com/xaionaro/reform"
	"github.com/xaionaro/reform/dialects/mysql"
	"github.com/xaionaro/reform/dialects/sqlite3"
	"log"
	"os"
	"runtime"
	"strings"
	"time"
)

const (
	SQL_LOGGER_TRACEBACK_DEPTH int = 10
)

type smartLogger struct {
	dbName      string
	traceLogger reform.Logger
	errorLogger reform.Logger
	traceEnable bool
	errorEnable bool
}

func (logger smartLogger) queryWrapper(query string) string {
	var where string

	for i := 2; i < 32; i++ {
		_, filePath, _, ok := runtime.Caller(i)
		if !ok {
			break
		}
		if strings.HasSuffix(filePath, "_reform.go") {
			continue
		}
		if strings.HasSuffix(filePath, "_common.go") {
			continue
		}
		if strings.HasSuffix(filePath, "querier.go") {
			continue
		}
		if strings.HasSuffix(filePath, "querier_selects.go") {
			continue
		}
		if strings.HasSuffix(filePath, "querier_commands.go") {
			continue
		}
		if filePath == `<autogenerated>` {
			continue
		}
		if strings.HasSuffix(filePath, "_generatedModelFunctions.go") {
			continue
		}
		if strings.HasSuffix(filePath, "_generatedMethods.go") {
			continue
		}

		whereArray := make([]string, SQL_LOGGER_TRACEBACK_DEPTH, SQL_LOGGER_TRACEBACK_DEPTH)
		for j := 0; j < SQL_LOGGER_TRACEBACK_DEPTH; j++ {
			_, filePath, line, ok := runtime.Caller(i + j)
			pathParts := strings.Split(filePath, "/")
			fileName := pathParts[len(pathParts)-1]
			if !ok || strings.HasSuffix(fileName, ".s") {
				whereArray = whereArray[SQL_LOGGER_TRACEBACK_DEPTH-j:]
				break
			}
			whereArray[SQL_LOGGER_TRACEBACK_DEPTH-1-j] = fmt.Sprintf("%v:%v", fileName, line)
		}
		where = "[" + strings.Join(whereArray, " -> ") + "] "
		break
	}
	return fmt.Sprintf("%v[db:%s] %s", where, logger.dbName, query)
}
func (logger *smartLogger) SetTraceEnable(enable bool) {
	logger.traceEnable = enable
}
func (logger *smartLogger) SetErrorEnable(enable bool) {
	logger.errorEnable = enable
}
func (logger smartLogger) Before(query string, args []interface{}) {
	if logger.traceEnable {
		logger.traceLogger.Before(logger.queryWrapper(query), args)
	}
	return
}
func (logger smartLogger) After(query string, args []interface{}, d time.Duration, err error) {
	if err != nil {
		if logger.errorEnable {
			logger.errorLogger.After(logger.queryWrapper(query), args, d, err)
		}
	} else {
		if logger.traceEnable {
			logger.traceLogger.After(logger.queryWrapper(query), args, d, err)
		}
	}
	return
}

func GetMysqlConnectionString(host, port, user, pass, dbname, protocol, socket string) string {
	switch protocol {
	case "tcp", "tcp6":
		return fmt.Sprintf("%s:%s@%s([%s]:%s)/%s?parseTime=true", user, pass, protocol, host, port, dbname)
	case "unix":
		return fmt.Sprintf("%s:%s@%s(%s)/%s?parseTime=true", user, pass, protocol, socket, dbname)
	default:
		panic(fmt.Errorf("This protocol is not supported: %v", protocol))
	}
	return ""
}

func NewReformDb(name, driver, connectionString string, traceLogger reform.Logger, errorLogger reform.Logger, traceEnable bool) (*reform.DB, *sql.DB, error) {
	db, err := sql.Open(driver, connectionString)
	if err != nil {
		return nil, nil, err
	}

	logger := smartLogger{dbName: name, traceLogger: traceLogger, errorLogger: errorLogger}
	logger.SetTraceEnable(traceEnable)
	logger.SetErrorEnable(true)

	switch driver {
	case "mysql":
		return reform.NewDB(db, mysql.Dialect, logger), db, nil
	case "sqlite3":
		return reform.NewDB(db, sqlite3.Dialect, logger), db, nil
	default:
		return nil, nil, fmt.Errorf("Unknown driver: ", driver)
	}

	return nil, nil, fmt.Errorf("This shouldn't happened")
}

func FileToReformLogger(file *os.File) reform.Logger {
	logger := log.New(file, "SQL: ", log.Flags())
	return reform.NewPrintfLogger(logger.Printf)
}

